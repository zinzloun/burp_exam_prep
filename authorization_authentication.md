### OAuth account hijacking via redirect_uri
<b>Workflow</b><br/>
Login to the portal using OAuth -> OAuth server authentication (yes) -> Portal (authenticated)  with auth code in the QS
<br>![img](./img/5.png)<br>
In the repeater since we are already authenticated, we can see the cookie session already set
<br>![img](./img/6.png)<br>
We can modify the redirect_uri parameter without get any error. The parameter is used to generate the redirect
<br>![img](./img/7.png)<br>
Now redirect the request to our payload hosted into the exploit server
<br>![img](./img/8.png)<br>
After delivered to the victim the payload, we can inspect the exploit access log to get the leaked auth code:
<br>![img](./img/9.png)<br>
Now we can use the code to access the portal bypassing the authentication process:
https://YOUR-LABID.web-security-academy.net/oauth-callback?code=T2QW7SXUMEHWY_bpSSTnNucJRfhWhQRtbj2GQpqAINC

### Forced OAuth profile linking
#### Lab
The lab gives you the option to attach a social media profile to your account so that you can log in via OAuth instead of using the normal username and password. Due to the insecure implementation of the OAuth flow by the client application, an attacker can manipulate this functionality to obtain access to other users' accounts.

To solve the lab, use a CSRF attack to attach your own social media profile to the admin user's account on the blog website, then access the admin panel and delete Carlos.

The admin user will open anything you send from the exploit server and they always have an active session on the blog website. 

Proceed to attach the social media profile to the blog account, once done logout and try to login using the social media profile option, you should be able to get in. Inspecting the autorithation flow we can see that the application does not send the <b>state</b> parameter (1), permetting a CSRF attack
<br>![img](./img/125.png)<br>

Even the redirection performed by the authorization server, of course, does not containg the state parameter, but only the authorization code generated by the authorization server.
<br>![img](./img/126.png)<br>

After that the application should use the authorization code to get an access token, performing a POST request to the serviceâ€™s token endpoint. This step is missing in the Lab, or I have missed the request in Burp ðŸ˜¥. The important thing here that we can trick an administrator to make a request containing our authorization code that it will be associated with her profile, to do that we have to intercept the request containing our code, drop it, otherwise the code will be invalidated, and craft an exploit to be delivered to the administrator user.
So first of all enable Interception in Burp, then from <b>my-account page click again on Attach a social profile</b>
<br>![img](./img/127.png)<br>

Forward the first request, then the second should be the one containing the auth code, right click and copy the URL (1)
<br>![img](./img/128.png)<br>

and drop the request. Now log-out from the blog, <b>go to the exploit server and insert the following payload into the Body</b>
```
<iframe src="https://0af900c8036259bcc043118a00a800ba.web-security-academy.net/oauth-linking?code=g6MeFfYAt9eEXUd_707knVmgZxRLIYYeIM1q9Oxe_lw" width=0 height=0></iframe>
```
Click Store and the Deliver to the victim, once the admin user will visit the the exploit the pending OAuth flow will be completed using your social media profile, attaching it to the administrator account.

Now log-in again using <b>Log in with social media</b> and you should get in as an administrator user 

#### References
+ https://auth0.com/docs/secure/attack-protection/state-parameters
+ https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type 

### Multi-step process with no access control on one step 
### Lab
This lab has an admin panel with a flawed multi-step process for changing a user's role. 
To solve the lab, log in using the credentials wiener:peter and exploit the flawed access controls to promote yourself to become an administrator.
Before to promote a user as admin 
<br>![img](./img/83.png)<br>

A confirmation step is required. In this step an hiddne input field is sent to validate the action as show below
<br>![img](./img/84.png)<br>
In this scenario, since no security mechanism are implemented in the confirmation step, we can easely promote oruselves to an admin user. Let's try lo open an incognito session in the browser to login as a normal user (wiener)
<br>![img](./img/85.png)<br>
Now in the legitim request made before by the administrator to promote carlos, we can just change the cookie session to ours (1) and the username parameter according (2):
<br>![img](./img/86.png)<br>
Submitting the modified request we solve the lab

#### References:
+ https://portswigger.net/web-security/access-control

### Broken brute-force protection with IP block
#### Lab
This lab is vulnerable due to a logic flaw in its password brute-force protection. To solve the lab, brute-force the victim's password, then log in and access their account page.

Trying to brute-force the login we can notice that after 3 failed attempts we are blocked for 1 minute, so a lock-out policy it is in place. Now it is quite common that the policy is based on the IP address of the incoming request. Poorly configured policy reset the failed counter attempts after a successfull login, we can try to verify this configuration using the following approach within a minute:
+ 2 failed login using carlos as username
+ a succefull login as user wiener
+ another failed attempt as user carlos
The result is that we are not blocked, so we can try to brute-force the login using the following sequence:
+ login brute-force attempt 1
+ login brute-force attempt 2
+ successfull login user wiener credentials
+ login brute-force attempt 3
+ login brute-force attempt 4
+ successfull login user wiener credentials
+ ...

and so on. To solve this lab I used Turbo Intruder exstension, you can get more information in the reference section about this toool. I created a custom list to feed Turbo intruder based on the passwords list provided: https://portswigger.net/web-security/authentication/auth-lab-passwords, that implements the sequence schema illustrated above. You can download the customized list for Turbo Intrudere [here](./file/wl_auth.txt).

Once we have intercepted a login request we can send it to Turbo Intruder, here I configured the Python payload to execute a request after another, so I set
```
concurrentConnections=1,
requestperConnetction=1,
```
and the wordlist that I created. The payload will send a request for each line in the file, replacing the <b>%s</b>
value with the a single payload row of the file, then if the response is not a 404 error, is added to the list results.
<br>![img](./img/87.png)<br>

Now lunch the attack, go for a coffee since it will take some time (in Burp CE using Turbo Intruder the requests are throttled). 

In the result's table to find out if we succeed, we have to order the results for the state, looking for 302 responses (redirection to the account details), filter out those related to wiener, we should see a request having carlos as username, the value of the password parameter is the one that is correct.
<br>![img](./img/88.png)<br>


#### References:
+ https://blog.intigriti.com/2022/03/01/hacker-tools-turbo-intruder

### Brute-forcing a stay-logged-in cookie
#### Lab

This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.

To solve the lab, brute-force Carlos's cookie to gain access to his "My account" page.
Your credentials: wiener:peter
Victim's username: carlos
[Here](https://portswigger.net/web-security/authentication/auth-lab-passwords) you can download the password's wordlist. 

First of all log-in using wiener credentials, check the option to <b>Stay logge in</b>, inspect the request for the <b>my-account page</b> you will notice that a cookie <b>stay-logged-in</b> is set, the value is encoded in Base64, using Inspector we can infer that could be in the form of username:encoded_password, the username is in plain text. 
<br>![img](./img/129.png)<br>
The I used a <b>Python script, hash-id</b>, to try to guess the encoding form, that could md5.
<br>![img](./img/130.png)<br>
Knowing that we can think to brute-force the password for the user carlos, setting the cookie vakue according. The process that I followed was: 
- create a wordlist containing the payloads  <b>b64(carlos:md5(password))</b>, the password value are taken from the provided password wordlist
- using Turbo Intruder to brute-force the cookie for the user carlos, in this process we have to check if the server response contains the phrase <b>Update email</b> since this feature is available only if you are successfully logged-in

To generate the cookie encoded wordlist I used [this](./file/create_session_cookie.py) Python script. The script read the passwords contained in a file, encode the value in md5, then encode the string carlos:md5_password_hash in base 64 and save the value in another file. There is even a test case where you can verify that the hash value for the md5 encoded password and the cookie value for stay-logged-in for wiener. You can download the generated list with the encoded cookie [here](./file/cookieB64.txt).

Then we can proceed using Turbo Intruder to try to brute-force the cookie for carlos, before to proceed log-out from the blog, then try to access my-account, intercept the request (you will be redirect to the log-in page) and send to intruder. Set the payload placeolder (1) and the condition to add the entry in the result table (2)
<br>![img](./img/131.png)<br>
After a while you should see the entry added to the result containing the cookie value used to access the account page of carlos
<br>![img](./img/132.png)<br>
The lab should be solved

### JWT authentication bypass via weak signing key
JWT attacks involve a user sending modified JWTs to the server in order to achieve a malicious goal. Typically, this goal is to bypass authentication and access controls by impersonating another user who has already been authenticated. 
#### Lab
<i>Please note that you have installed the JWT editor exstension to follow the solution</i>
This lab uses a JWT-based mechanism for handling sessions. It uses an extremely weak secret key to both sign and verify tokens. This can be easily brute-forced. To solve the lab, first brute-force the website's secret key. Once you've obtained this, use it to sign a modified session token that gives you access to the admin panel at /admin, then delete the user carlos.

You can log in to your own account using the following credentials: wiener:peter 

Let's login as wiener user, going to the proxy histoty we can notice that, having the JWT editor installed, 3 tows are highlighted
<br>![img](./img/106.png)<br>

send the request to the account page to the Repeater. Passing to the JSON Web Token tab we can see out JWT decoded
<br>![img](./img/107.png)<br>

Now being authenticated as wiener, tring to send the request to the admin panel, we can notice that the admin panel is only accessible by the administrators. 
<br>![img](./img/108.png)<br>

Knowing that the secret key is weak we can use hashcat to brute-force it. You can get the wordlist to use from [here](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list). I used the following command:
```
.\hashcat -m 16500 eyJraWQiOiJiMTNjZGEzMS02MDNlLTQ2MjQtYjc0MS0wYWU1ZDIxNTMxYmQiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NDIyNjQxN30.T0XcbTnWQ1MWDn5ZcfU46AEU0i1K4Ta5yhuiCWby_lM "D:\wordlists\jwt.secrets.list.txt"
```
The m switch value refers to the JWT token mode, fallowed by my JWT token value, the third parameter is the wordlist path file to use to brute-force the token. After some seconds the secret key is cracked:
<br>![img](./img/109.png)<br>

Now let's proceed to encode the secret in B64 format:
```
c2VjcmV0MQ==
```
Then we generate a new symmetric key as follows:
select JWT editor keys (1), then New symmetric key (2), in the newly opened window click Generate (3), in the new generated key replace the value of the <b>k</b> property with the encoded value of the secret found in the previous step, then click OK (4). 
<br>![img](./img/110.png)<br>

Now switch back to Repeater, in the JSON web token tab
, modify the sub value as administrator (1), then click Sign (2), in the newly open window select the key that we have previously generated (3), then click Ok (4). Now notice that the hex value of the signature is changed (5).
<br>![img](./img/111.png)<br>

Resend the request to the admin page using the modified token and we should be able to access the admin page
<br>![img](./img/112.png)<br>

Now sendig the following request to solve the Lab:
```
/admin/delete?username=carlos
```

#### References
+ https://portswigger.net/web-security/jwt
+ https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it
+ https://portswigger.net/web-security/jwt/working-with-jwts-in-burp-suite
+ https://hashcat.net/wiki/doku.php?id=hashcat
